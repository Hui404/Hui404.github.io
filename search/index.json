[{"content":"STM32 的IIC外设 ​\tSTM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持7位、10 位设备地址，支持DMA数据传输，并具有数据校验功能。\nSTM32 的 IIC 架构 通讯引脚 ​\tI2C 的所有硬件架构都是根据图中左侧SCL线和SDA线展开的(其中的SMBA线用于SMBUS的 警告信号，I2C通讯没有使用)。STM32芯片有多个I2C外设，它们的I2C通讯信号引出到不同的 GPIO 引脚上，使用时必须配置到这些指定的引脚\nIIC的结构体参数 1 2 3 4 5 6 7 8 9 10 typedef struct { uint32_t I2C_ClockSpeed; uint16_t I2C_Mode; uint16_t I2C_DutyCycle; uint16_t I2C_OwnAddress1; uint16_t I2C_Ack; uint16_t I2C_AcknowledgedAddress; }I2C_InitTypeDef; IIC代码参考 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 #include \u0026#34;i2c.h\u0026#34; //EEPROM设备地址 #define EEPROM_Addr\t0xA0 /* 1.初始化IIC相关的GPIO 2.配置IIC外设的工作模式 3.编写IIC写入EEPROM的Byte Write函数 4.编写IIC读取EEPROM的RANDOM Read函数 5.使用Read函数及Write函数进行读写校验 6.编写page write 及seq read函数并校验 */ void I2C_EE_Config(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); I2C_InitTypeDef I2C_InitStructure; I2C_InitStructure.I2C_Mode = I2C_Mode_I2C; //I2C模式 I2C_InitStructure.I2C_ClockSpeed = 400000; //配置时钟SCL频率 I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2; //2:1 I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; //使能应答 I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; //使用7位地址模式 I2C_InitStructure.I2C_OwnAddress1 = 0x5f;// STM上I2C自身地址 (自己选择一个7位地址，不要跟其他I2C设备的地址冲突) I2C_Init(I2C1, \u0026amp;I2C_InitStructure); I2C_Cmd(I2C1, ENABLE); } //向EEPROM写入一个字节 void EEPROM_Byte_Write(uint8_t addr, uint8_t data) { I2C_GenerateSTART(I2C1, ENABLE); //产生起始信号 //检测EV5事件是否产生 while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT) == ERROR); //EV5事件被检测到 I2C_Send7bitAddress(I2C1, EEPROM_Addr, I2C_Direction_Transmitter); //检测EV6 （和EV8事件） while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR); //EV6事件被检测到 //stm32会把第一个发送的数据认作地址 I2C_SendData(I2C1, addr); //检测EV8事件 while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR); //EV8事件被检测到，开始发送数据 I2C_SendData(I2C1, data); //检测EV8_2（结束）事件(即数据传输完成) while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR); //检测到EV8_2事件，产生停止信号 I2C_GenerateSTOP(I2C1, ENABLE); } //从EEPROM读取数据 void EEPROM_Read(uint8_t addr, uint8_t *data, uint8_t numByteToRead)\t//形参是指针时就可以改变实参 { I2C_GenerateSTART(I2C1, ENABLE); //产生起始信号 //检测EV5事件是否产生 while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT) == ERROR); //EV5事件被检测到 I2C_Send7bitAddress(I2C1, EEPROM_Addr, I2C_Direction_Transmitter); //检测EV6 （和EV8事件） while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR); //EV6事件被检测到 //stm32会把第一个发送的数据认作地址 I2C_SendData(I2C1, addr); //检测EV8事件 while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR); //第二次起始信号 I2C_GenerateSTART(I2C1, ENABLE); //产生起始信号 //检测EV5事件是否产生 while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT) == ERROR); //EV5事件被检测到 I2C_Send7bitAddress(I2C1, EEPROM_Addr, I2C_Direction_Receiver); //检测EV6 （和EV8事件） while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR); //检测到EV6事件,会自动接收一个字节 while(numByteToRead) { if(numByteToRead == 1) { //如果是最后一个字节，产生一个非应答信号 I2C_AcknowledgeConfig(I2C1, DISABLE); } //检测EV7事件 while(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED) == ERROR); //EV7事件被检测到，即数据寄存器有新的有效数据 *data =I2C_ReceiveData(I2C1); data++; //指针指向下一个字节 numByteToRead--; }\t//数据传输完成，产生停止信号 I2C_GenerateSTOP(I2C1, ENABLE); //结束后，将应答配置默认为使能状态,以便下次通讯 I2C_AcknowledgeConfig(I2C1, ENABLE); } void EEPROM_WaitForWriteEnd(void) { } ","date":"2024-11-20T22:00:08+08:00","permalink":"https://Hui404.github.io/p/stm32%E8%BD%AF%E4%BB%B6%E8%AF%BB%E5%86%99iic/","title":"STM32软件读写IIC"},{"content":"IIC通信协议 ​\tIIC（Inter-Integrated Circuit）是 IIC Bus 简称，中文叫集成电路总线。它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。\nIIC物理层 它是一个支持设备的总线 一个IIC总线只使用两条总线线路，一条双向串行数据线(SDA)，一条串行时钟线(SCL) 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问 总线通过上拉电阻接到电源。当IIC设备空闲时，会输出高阻态，而当所有设备都空闲，都 输出高阻态时，由上拉电阻把总线拉成高电平 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线 具有三种传输模式：标准模式传输速率为100kbit/s，快速模式为400kbit/s，高速模式下可达 3.4Mbit/s，但目前大多IIC设备尚不支持高速模式 连接到相同总线的IC数量受到总线的最大电容400pF限制 IIC协议层 IIC 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节\nIIC的基本读写过程 IIC通讯过程的基本结构\n​\t这些图表示的是主机和从机通讯时，SDA线的数据包序列 ​\t其中S表示由主机的IIC接口产生的传输起始信号(S)，这时连接到IIC总线上的所有从机都会 接收到这个信号。\n起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号(SLAVE_ADDRESS)。 在IIC总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设 备就被选中了，没被选中的设备将会忽略之后的数据信号。根据IIC协议，这个从机地址可以是 7 位或10位。 ​\t在地址位之后，是传输方向的选择位，该位为0时，表示后面的数据传输方向是由主机传输至从 机，即主机向从机写数据。该位为1时，则相反，即主机由从机读数据。 从机接收到匹配的地址后，主机或从机会返回一个应答(ACK)或非应答(NACK)信号，只有接收 到应答信号后，主机才能继续发送或接收数据。\n写数据 ​\t若配置的方向传输位为“写数据”方向，即第一幅图的情况，广播完地址，接收到应答信号后，主机开始正式向从机传输数据(DATA)，数据包的大小为8位，主机每发送完一个字节数据，都 要等待从机的应答信号(ACK)，重复这个过程，可以向从机传输N个数据，这个N没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号(P)，表示不再传输数据\n读数据 ​\t若配置的方向传输位为“读数据”方向，即第二幅图的情况，广播完地址，接收到应答信号后， 从机开始向主机返回数据(DATA)，数据包大小也为8位，从机每发送完一个数据，都会等待主 机的应答信号(ACK)，重复这个过程，可以返回N个数据，这个N也没有大小限制。当主机希 望停止接收数据时，就向从机返回一个非应答信号(NACK)，则从机自动停止数据传输\n读和写数据 ​\t除了基本的读写，IIC通讯更常用的是复合格式，即第三幅图的情况，该传输过程有两次起始信 号(S)。一般在第一次传输中，主机通过SLAVE_ADDRESS寻找到从设备后，发送一段“数据”， 这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与SLAVE_ADDRESS的 区别)；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读 写地址，第二次则是读写的实际内容。\n通讯的起始（S）和停止（P）信号 ​\t上文中提到的起始(S)和停止(P)信号是两种特殊的状态，见图起始和停止信号。当SCL线是高 电平时SDA线从高电平向低电平切换，这个情况表示通讯的起始。当SCL是高电平时SDA线由 低电平向高电平切换，表示通讯的停止。起始和停止信号一般由主机产生。\n数据有效性 ​\tIIC 使用SDA信号线来传输数据，使用SCL信号线进行数据同步。见图数据有效性。SDA数据 线在SCL的每个时钟周期传输一位数据。传输时，SCL为高电平的时候SDA表示的数据有效， 即此时的SDA为高电平时表示数据“1”，为低电平时表示数据“0”。当SCL为低电平时，SDA 的数据无效，一般在这个时候SDA进行电平切换，为下一次表示数据做好准备\n​\t每次数据传输都以字节为单位，每次传输的字节数不受限制\n地址及数据方向 ​\tIIC 总线上的每个设备都有自己的独立地址，主机发起通讯时，通过SDA信号线发送设备地址 (SLAVE_ADDRESS)来查找从机。IIC协议规定设备地址可以是7位或10位，实际中7位的地址 应用比较广泛。紧跟设备地址的一个数据位用来表示数据传输方向，它是数据方向位(R/)，第8 位或第11位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写 数据\n​\t读数据方向时，主机会释放对SDA信号线的控制，由从机控制SDA信号线，主机接收信号，写 数据方向时，SDA由主机控制，从机接收信号\n响应（应答与非应答） ​\tIIC 的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为 数据接收端时，当设备(无论主从机)接收到IIC传输的一个字节数据或地址后，若希望对方继 续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端 希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个 停止信号，结束信号传输\n​\t传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA的控制权，由数据接收端控制 SDA，若SDA为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)\n","date":"2024-11-19T23:32:18+08:00","permalink":"https://Hui404.github.io/p/iic%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/","title":"IIC通讯协议"},{"content":"串口通信 ​\tSTC89C52（下面简称C51）系列单片机内部集成了一个功能很强的全双工串行通信口，与传统8051单片机的串口完全兼容。设有两个互相独立的接收、发送缓存器，可以同时发送和接收数据。发送缓存器只能写入不能读出，接收缓存器只能读出不能写入，两个缓存器共用一个地址吗（99H）。\n​\t串行通信外设有4种工作方式，其中两种方式的波特率是可变的，另两种是固定的，以供不同应用场合选用。波特率由内部定时器/计数器产生，用软件设置不同的波特率和选择不同的工作方式。\n​\tC51系列单片机串行口对应的引脚是P3.0（RxD）和P3.1（TxD）。\n串行口控制寄存器 C51系列单片机的串行口设有两个控制寄存器：SCON（串行控制寄存器）和PCON（波特率选择特殊功能寄存器）\nSCON SM0和SM1共同确定串行的工作方式：\nSM2：允许方式2或方式3多机通信控制位 REN：允许/禁止串口接收控制位，REN=1为允许接收 TB8:\t在方式2或方式3，为要发送的第九位数据，按需要由软件置位或清0 RB8:\t在方式2或方式3，是接收到的第九位数据 TI:\t发送中断请求标志位 RI:\t接收中断请求标志位\n​\t串行通信的中断请求：当一帧发送完成，内部硬件自动置位TI，即TI=1，请求中断处理；当接收完一帧信息时，内部硬件自动置位RI，即RI=1，请求中断处理\nPCON PCON只有高2位（B6、B7）是属于串口的\nSMOD:\t波特率选择位 SNOD0: 帧错误检测有效控制位\n串行口工作模式1：8位UART，波特率可变 实验 P32和P33各接一个按键S3、S4。按下S3发送字符“1”到PC机，按下S4发送字符“2”到PC机的按键。- PC机用串口助手软件将接收数据显示。 晶振11.0592MHz，串行口用方式1，波特率9600bps 接收PC发来的数据，在P1口上显示 用LCD1602液晶屏显示接收到的数据 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 #include \u0026lt;reg52.h\u0026gt; sbit E\t= P2^6; sbit RS = P2^4; sbit RW = P2^5; sbit S1 = P3^0; sbit S3 = P3^2; sbit S4 = P3^3; #define LCD_Data P0 unsigned char flag1 = 1; unsigned int time0 = 0; unsigned int time1 = 0; unsigned char S1_flag0 = 1; unsigned char S1_flag1 = 1; unsigned char S3_flag0 = 1; unsigned char S3_flag1 = 1; unsigned char S4_flag0 = 1; unsigned char S4_flag1 = 1; unsigned char clean_flag0 = 0; unsigned char usart_send_flag1 = 0; unsigned char usart_send_flag2 = 0; unsigned char Addr = 1; unsigned char LCD_flag0 = 0; unsigned char Num = 1; void LCD_Delay(unsigned char time) {\twhile(time--) { unsigned char i = 0; for(i = 0; i\u0026lt;123;i++); } } void LCD_WriteCom(unsigned char com) {\tRS = 0; RW = 0; LCD_Data = com; E = 1; LCD_Delay(1); E = 0; LCD_Delay(1); } void LCD_WriteData(unsigned char Data) {\tRS = 1; RW = 0; LCD_Data = Data; E = 1; LCD_Delay(1); E = 0; LCD_Delay(1); } void LCD_Init(void) { LCD_WriteCom(0x38);\t//设置16x2显示，5x7点阵，8位数据接口 LCD_WriteCom(0x0C);\t// 0000 1100 LCD_WriteCom(0x06);\t//0000 0110 LCD_WriteCom(0x01);\t//清除 复位 } void LCD_SetCursor(unsigned Line, unsigned char Column) { if(Line == 1) { LCD_WriteCom(0x80|(Column - 1)); } else { LCD_WriteCom(0x80|(Column) + 0x40); } } void LCD_ShowNum(unsigned char Line, unsigned char Column, unsigned char Num) { LCD_SetCursor(Line, Column); LCD_WriteData(\u0026#39;0\u0026#39; + Num); } void Uart_SendByte(unsigned char Byte) { SBUF = Byte; while(TI == 0); TI = 1; } //11.0592Mhz void Uart_Init(void) { SCON = 0x50;\t//8位数据，可变波特率 PCON \u0026amp;= 0x7F;\t//不使能波特率倍速位 TMOD \u0026amp;= 0x0F;\t//清除定时器1模式 TMOD |= 0x20; //设定定时器1为8位自动重装 TL1 = 0xFD;\t//设定定时初值 TH1 = 0xFD;\t//设定定时器重装值 ET1 = 0;\t//不需要进中断 TR1 = 1; //启动定时器1 ES = 1;\t//串口中断 } void Time_Init(void) { EA = 1; TMOD = 0x01; ET0 = 1; TR0 = 1; TH0 = 64535 / 256; TL0 = 64535 % 256; } void main(void) { LCD_Init(); Time_Init(); Uart_Init(); while(1) { if(Addr == 17) { Addr = 0x41;\t} if(usart_send_flag1 == 1) { Uart_SendByte(\u0026#39;1\u0026#39;); LCD_ShowNum(1, Addr++, 1); usart_send_flag1 = 0; } if(usart_send_flag2 == 1) { Uart_SendByte(\u0026#39;2\u0026#39;); LCD_ShowNum(1, Addr++, 2); usart_send_flag2 = 0; } if(LCD_flag0 == 1) {\tLCD_ShowNum(1, Addr++, Num - \u0026#39;0\u0026#39;); LCD_flag0 = 0; } if(clean_flag0 == 1) {\tAddr = 1; LCD_WriteCom(0x01); clean_flag0 = 0; } } }\tvoid Time0_IT(void) interrupt 1 { time0 ++; time1 ++; TH0 = 45535/256; TL0 = 45535%256; if(time0 == 25) {\tif(flag1 == 0) { flag1 = 1; } else if(flag1 == 1) { flag1 = 0; } time0 =0; } if(time1 == 1)\t//非阻塞按键扫描 { S1_flag1 = S1_flag0;\t//保存上一次的值 S1_flag0 = S1;\t//获取新的值 S3_flag1 = S3_flag0;\t//保存上一次的值 S3_flag0 = S3;\t//获取新的值 S4_flag1 = S4_flag0;\t//保存上一次的值 S4_flag0 = S4;\t//获取新的值 if(S1_flag1 == 1 \u0026amp;\u0026amp; S1_flag0 == 0) { clean_flag0 = 1; } if(S3_flag1 == 1 \u0026amp;\u0026amp; S3_flag0 == 0) { usart_send_flag1 = 1; } if(S4_flag1 == 1 \u0026amp;\u0026amp; S4_flag0 == 0) { usart_send_flag2 = 1; } time1 = 0; } } void Uart_Read() interrupt 4 { if(RI == 1) { Num = SBUF; LCD_flag0 = 1; RI = 0; } } 现象 ","date":"2024-11-18T18:18:02+08:00","permalink":"https://Hui404.github.io/p/c51%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C/","title":"C51串口通信实验"},{"content":"STM32的SPI外设 STM32内部集成了硬件SPI收发电路，可以由硬件自动执行时钟生成、数据收发等功能，减轻CPU的负担 可配置8位/16位数据帧、高位先行/低位先行 时钟频率：fpclk/(2,4,6,8,16,32,64,128,256) 支持多主机模型、主或从操作 可精简为半双工/单工通信 支持DMA 兼容I2S协议 硬件SPI资源：SPI1、SPI2 SPI基本结构 SS：使用GPIO控制\nSTM32上的SPI的引脚 可以看到SCK、MISO、MOSI分别对应STM32的PA5、PA6、PA7,至于SS一般采用其他的IO口进行控制\n下面则是SPI2的引脚\n程序 相对于硬件SPI，仅修改了SPI.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026#34;SPI.h\u0026#34; void MySPI_W_SS(uint8_t BitValue)\t//SS 还是使用软件模拟 { GPIO_WriteBit(GPIOC, GPIO_Pin_0, (BitAction)BitValue);\t//BitAction 非0即1 } void MySPI_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //\tSS:PC0 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC, \u0026amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7; // CLK:PA5 DI/MOSI:PA7 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; //MISO:PA6 GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //SPI初始化 SPI_InitTypeDef SPI_InitStructure; SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;\t//分频 72Mhz/128 SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge; //第一个边沿采样 SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low; SPI_InitStructure.SPI_CRCPolynomial = 7; //手册489页最红有提到默认值为 0x0007 SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;\t//8位数据帧 SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //双线全双工 SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; //高位先行 SPI_InitStructure.SPI_Mode = SPI_Mode_Master;\t//选择为主机 SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; SPI_Init(SPI1, \u0026amp;SPI_InitStructure); SPI_Cmd(SPI1, ENABLE); //默认给SS输出高电平 MySPI_W_SS(0); } //初始信号 void MySPI_Start(void) { MySPI_W_SS(0); } //终止信号 void MySPI_Stop(void) { MySPI_W_SS(1); } //通过交换一个字节接收到的数据 uint8_t MySPI_SwapByte(uint8_t ByteSend) { while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) != SET);\t//等待TXE为1 SPI_I2S_SendData(SPI1, ByteSend);\t//发送数据，写入DR时会自动清除TXE标志位 while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) != SET);\t//等待RXNE为1 return SPI_I2S_ReceiveData(SPI1);\t//接收数据，读DR时会自动清除RXNE标志位 } ","date":"2024-11-17T12:59:02+08:00","permalink":"https://Hui404.github.io/p/%E7%A1%AC%E4%BB%B6spi%E8%AF%BB%E5%86%99w25q64/","title":"硬件SPI读写W25Q64"},{"content":"人体安全电压：交流电36V，交流电流10mA 电压不可怕，可怕是电流流过身体\n","date":"2024-11-17T11:11:25+08:00","permalink":"https://Hui404.github.io/p/%E7%A1%AC%E4%BB%B61%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%AE%89%E5%85%A8%E8%A6%81%E7%82%B9/","title":"硬件(1)电路设计安全要点"},{"content":"","date":"2024-11-16T19:50:43+08:00","permalink":"https://Hui404.github.io/p/stm32%E7%A1%AC%E4%BB%B6%E8%AF%BB%E5%86%99w25q64/","title":"STM32硬件读写W25Q64"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include \u0026#34;SPI.h\u0026#34; void MySPI_W_SS(uint8_t BitValue) { GPIO_WriteBit(GPIOC, GPIO_Pin_0, (BitAction)BitValue);\t//BitAction 非0即1 } void MySPI_W_SCK(uint8_t BitValue) { GPIO_WriteBit(GPIOA, GPIO_Pin_5, (BitAction)BitValue);\t//BitAction 非0即1 } void MySPI_W_MOSI(uint8_t BitValue) { GPIO_WriteBit(GPIOA, GPIO_Pin_7, (BitAction)BitValue);\t//BitAction 非0即1 } uint8_t MySPI_R_MISO(void) { return GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6); } void MySPI_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //CS:PC0 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC, \u0026amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7; // CLK:PA5 DI/MOSI:PA7 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; //MISO:PA6 GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //初始化 赋予默认电平 MySPI_W_SS(1); MySPI_W_SCK(0); } //初始信号 void MySPI_Start(void) { MySPI_W_SS(0); } //终止信号 void MySPI_Stop(void) { MySPI_W_SS(1); } //通过交换一个字节接收到的数据 uint8_t MySPI_SwapByte(uint8_t ByteSend) { uint8_t i, ByteReceive = 0x00; for(i = 0; i \u0026lt; 8; i++) { MySPI_W_MOSI(ByteSend \u0026amp; (0x80 \u0026gt;\u0026gt; i)); //xx \u0026amp; 0x80 取xx的最高位置（0x1000 0000） MySPI_W_SCK(1); if (MySPI_R_MISO() == 1)ByteReceive |= (0x80 \u0026gt;\u0026gt; i); MySPI_W_SCK(0); } return ByteReceive; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026#34;W25Q64.h\u0026#34; void W25Q64_Init(void) { MySPI_Init(); } //读取设备ID void W25Q64_ReadID(uint8_t *MID, uint16_t *DID) //MID：厂商8位ID DID:厂商16位设备ID { MySPI_Start(); MySPI_SwapByte(0x9F); *MID = MySPI_SwapByte(0xFF); *DID = MySPI_SwapByte(0xFF); *DID \u0026lt;\u0026lt;= 8; *DID |= MySPI_SwapByte(0xFF); MySPI_Stop(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #include \u0026#34;usart.h\u0026#34; void NVIC_Configuration(void) { NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStructure); } void USART_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; //串口GPIO时钟 DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE); //串口外设时钟 DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK,ENABLE); //将USART Tx的GPIO设置为复用推挽输出模式 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin= DEBUG_USART_TX_GPIO_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(DEBUG_USART_TX_GPIO_PORT,\u0026amp;GPIO_InitStructure); //将USART Rx的GPIO设置为浮空输入模式 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_InitStructure.GPIO_Pin= DEBUG_USART_RX_GPIO_PIN; GPIO_Init(DEBUG_USART_RX_GPIO_PORT,\u0026amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATR;\t//波特率 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\t//硬件流控制 USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;\t//工作模式 发送还是接收 ， 这里是收发一起 USART_InitStructure.USART_Parity = USART_Parity_No;\t//校验位 USART_InitStructure.USART_StopBits = USART_StopBits_1;\t//停止位 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //针数据字长 USART_Init(USART1, \u0026amp;USART_InitStructure); //串口中断优先级配置 NVIC_Configuration(); //使能串口接收中断 USART_ITConfig(DEBUG_USARTx,USART_IT_RXNE,ENABLE); //使能串口 USART_Cmd(DEBUG_USARTx,ENABLE); } /* 发送一个字节 */ void Usart_SendByte(USART_TypeDef* pUSARTx, uint8_t data) { USART_SendData(pUSARTx, data); while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET) { } } /* 发送两个字节 */ void Usart_SendHalfWord(USART_TypeDef* pUSARTx, uint16_t data) { uint8_t temp_h,temp_l; temp_h = (data \u0026amp; 0xff00) \u0026gt;\u0026gt; 1; temp_l = data \u0026amp; 0xff; USART_SendData(pUSARTx, temp_h); while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET) { } USART_SendData(pUSARTx, temp_l); while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET) { } } /* 发送8位数据的数组 */ void Usart_SendArray(USART_TypeDef* pUSARTx, uint8_t *array, uint8_t num) { uint8_t i; for(i=0;i\u0026lt;num;i++) { Usart_SendByte(pUSARTx, *array++); } while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET); } /* 发送字符串 */ void Usart_SendStr(USART_TypeDef* pUSARTx, uint8_t *str) { do { Usart_SendByte(pUSARTx, *str++); }while(*str != \u0026#39;\\0\u0026#39;); while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET); } // 串口中断服务函数 void DEBUG_USART_IRQhandler(void) { uint8_t ucTemp; if(USART_GetITStatus(DEBUG_USARTx,USART_IT_RXNE)!=RESET) {\tucTemp = USART_ReceiveData(DEBUG_USARTx); USART_SendData(DEBUG_USARTx,ucTemp); if(ucTemp == \u0026#39;1\u0026#39;) { LED1_ON(); } else LED1_OFF(); }\t} 位操作\n#define PAout(n) BIT_ADDR(GPIOA_ODR_Addr,n) #define PAin(n) BIT_ADDR(GPIOA_IDR_Addr,n)\n比如： PAout(4) 等价于 GPIO_WriteBit(GPIOA, GPIO_Pin_4, Bit_SET); PAin(4)\t等价于 GPIO_WriteBit(GPIOA, GPIO_Pin_4, Bit_RESET);\n","date":"2024-11-15T19:55:32+08:00","permalink":"https://Hui404.github.io/p/spi%E8%AF%BB%E5%86%99w25q64/","title":"SPI读写W25Q64"},{"content":"W25Qxx简介 W25Qxx系列是一种低成本、小型化、使用简单的非易失性存储器，常应用于数据存储、字库存储、固件程序存储等场景\n存储介质：Nor Flash（闪存）\n时钟频率：80MHz/160MHz(Dual SPI)/320Mhz(Quad SPI)\nW25Qxx的存储容量为24位地址，“xx”表示了这个芯片不同的存储容量：\n1 2 3 4 5 6 7 W25Q40： 4Mbit / 512KByte\t(4Mbit = (4x1024)Kbit = (4096÷8)KByte = 512KByte) W25Q80： 8Mbit / 1MByte W25Q16： 16Mbit / 2MByte W25Q32： 32Mbit / 4MByte W25Q64： 64Mbit / 8MByte W25Q128：128Mbit / 16MByte W25Q256：256Mbit / 32MByte W25Q64接线图 引脚 功能 VCC、GND 电源（2.7~3.6V） CS（SS） SPI片选 CLK (SCK) SPI时钟 DI (MOSI) SPI主机输出从机输入 DO (MISO SPI主机输入从机输出 WP 写保护 HOLD 数据保持 硬件电路 Flash操作注意事项 写入操作时：\n写入操作前，必须先进行写使能 每个数据位只能由1改写为0，不能由0改写为1 写入数据前必须先擦除，擦除后，所有数据位变为1 擦除必须按最小擦除单元进行 连续写入多字节时，最多写入一页的数据，超过页尾位置的数据，会回到页首覆盖写入 写入操作结束后，芯片进入忙状态，不响应新的读写操作 读取操作时：\n直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取 ","date":"2024-11-14T17:47:36+08:00","permalink":"https://Hui404.github.io/p/w25q64%E5%AD%A6%E4%B9%A0/","title":"W25Q64学习"},{"content":"标题 语法：#一级标题 ##二级标题 ###三级标题\n快捷键：\nCtrl+数字1~6可以快速将选中的文本调成对应级别的标题\nCtrl+0可以快速将选中的文本调成普通文本\nCtrl+加号/减号对应标题级别进行加减\n段落 换行 快捷键：\nEnter(回车) 普通换行\nShift+Enter\t小换行\nEnter(回车) 普通换行 Shift+Enter\t小换行\n分割线 语法：—或者***+回车\n文字显示 字体 语法：\n粗体：用一队星号包裹\n删除线：用一对双飘号包裹\n下划线：用一对u标签包裹\n斜体：用一对单星号包裹\n高亮：用一对双等号包裹\n代码\n1 2 3 4 5 6 **这是粗体** ~~这是删除线~~ \u0026lt;u\u0026gt;这是下划线\u0026lt;/u\u0026gt; *这是斜体* ==这是高亮== \u0026lt;mark\u0026gt;这是高亮\u0026lt;/mark\u0026gt; 效果： 这是粗体 这是删除线 这是下划线 这是斜体 ==这是高亮==\n这是高亮\n快捷键：\n加粗：Ctrl + B 删除线：Shift + Alt +5 下划线： Ctrl + U 斜体： Ctrl + L\n上下标 代码:\n1 2 X^2^ H~2~O 效果：\nX^2^ H2O\n列表 无序列表 代码：\n*/-/+/\t+空格\n效果：\n1.同一级别：\n苹果 香蕉 橘子 2.子集类\n一级分类 二级分类 三级分类 可在当前分类中按 ==Tab==键快速分类\n快捷键：Crtl + Shift + ]\n有序列表 代码：\n1 数字+.+空格 效果：\n这是1 这是2 这是3 快捷键： Crtl + Shift + [\n任务列表 代码：\n1 2 - [ ] 练字 - [x] 学习 效果：\n练字 学习 区块显示 代码：\n1 \u0026gt; + 回车 效果：\n最外层\n外层\n内层\n最内层\n代码显示 行内代码 代码：\n1 `int a = 0;` (是在Esc按键下面的符合) 效果：\nint = a;\n快捷键：Ctrl + Shift + `\n代码块 代码：\n1 2 3 ```js/java/c#/text 内容 ``` 快捷键：Ctrl +Shift + K\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main(void) { print(\u0026#34;hello word！\u0026#34;); return 0; } 链接 代码：\n1 2 3 www.baidu.com [百度一下](https://www.baidu.com) [百度一下](https://www.baidu \u0026#34;https://www.baidu.com\u0026#34;) 效果：\nwww.baidu.com 百度一下 百度一下\n快捷键：Ctrl + K\n在文本内跳转\n跳转至标题\nps.按住Ctrl键再点击\n脚注 对文本进行解释说明\n代码：\n1 2 [^文本] [^文本]:解释说明 效果：\n说明1\n图片插入 代码：\n1 ![不显示的文字](图片路径 \u0026#34;图片标题\u0026#34;) 效果：\n表格 代码：\n1 2 3 4 5 | 1 | 2 | 3 | | :--- | :---| :---| | 4 | 5 | 6 | | 7 | 8 | 9 | | 10 | 11 | 12 | 效果：\n1 2 3 4 5 6 7 8 9 10 11 12 快捷键： Crtl + T\n说明的说明\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-11-13T22:21:45+08:00","permalink":"https://Hui404.github.io/p/typora%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","title":"Typora使用笔记"},{"content":"SPI通信 SPI是由Motorola公司开发的一种通用数据总线 四根通信线：SCK、MOSI（主机输出从机输入）、MISO（主机输入从机输出）、SS 同步，全双工 支持总线挂载多设备（一主多从） 与IIC相比 优点：\nSPI传输速度更快，最大传输速度取决与芯片厂商的设计需求 设计简单，不复杂 缺点：\nSPI的硬件开销大，通信线的个数比较多\n通信过程中，经常会有资源浪费的现象\n仅支持一主多从，不支持多主机\n硬件电路 所有的SPI设备的SCK、MOSI、MISO分别连在一起\n主机另外引出多条SS控制线，分别连接各从机的SS引脚\n输出的引脚配置为推挽输出，输入引脚配置为浮空或上拉输入\n一次只能选择一个SS引脚\n从机未被选中时，该从机的引脚必须切换为高阻态\n数据移位示意图 上升沿：数据移位 下降沿：采样数据\nSPI时序基本单元 起始条件：SS从高电平切换到低电平 终止条件：SS从低电平切换到高电平 SS在低电平期间，表示选用该从机\nSPI时序图 CPHA：时钟相位\n模式1 交换一个字节（模式1） CPOL=0：空闲状态，SCK为低电平 CPHA=1：SCK第一个边沿~~（即上升沿）移出数据，第二个边沿（即下降沿）~~移入数据 SPI没有硬性规定MOSI的默认电平，但是从机的MISO必须置回高阻态\n模式0（用的最多） 交换一个字节（模式0） CPOL=0：空闲状态，SCK为低电平 CPHA=1：SCK第一个边沿移~~（即上升沿）移入数据，第二个边沿（即下降沿）~~移出数据 为什么模式0最为广泛使用，明明模式1更符合常理？经过网上查证，大概分为以下几点\n模式0是最早定义的SPI时序模式，兼容性强 模式0采用下降沿移出数据，稳定性好 很多人刚开始学的就是模式0，于是就模式0就成了默认模式了 SPI1挂载在在APB2上 SPI2和SPI3挂载在APB1上 GPIO全部都挂载在APB2上\n配置时钟时要相对应\n编程技巧\n1 2 3 4 5 6 7 8 #define DE_BUG\t1 #if\tDE_BUG #define LED P0 #else #define LED P1 //通过DE_BUG来使用不同的宏 ","date":"2024-11-13T22:20:22+08:00","permalink":"https://Hui404.github.io/p/stm32%E4%B8%8Espi%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/","title":"STM32与SPI通信协议"},{"content":"LCD1602简介 LCD1602字符型液晶（每行显示16个字符，一共可以显示两行）——一种专门用来显示字母、数字、符号的点阵型液晶模块。它由若干个5x7或者5x10的点阵字符组成，每个点阵字符位都可以用来显示一个字符，每位之间有一个点距的间隔，每行之间也有间隔，起到了字符间距和行间距的作用，正因为如此，所以它不能很好的显示图片。\nLCD1602主要技术参数 LCD1602的接口 VSS：接地 VDD：接电源正级，注意电压即可 VL: 接地 RS: 当RS为高电平时，对1602进行数据字节的传输操作，而为低电平时，则进行命令字节的传输操作 R/W：高电平时读取1602的数据，反之则对1602进行写数据操作 E\t：使能信号，可以看作LCD1602的时钟信号，用以产生脉冲实现写数据操作等等 D0~D7：数据并行口，用于传输数据，占用8个IO口\n基本操作时序 LCD1602一般只作为显示使用，不太需要进行读操作和读数据\n写指令 输入：RS=L,RW=L,D0~D7=指令码，E=高脉冲（将E置为高电平后，再给低电平以产生高脉冲）\n写数据 输入：RS=H,RW=L,D0~D7=数据，E=高脉冲\nRAM地址映射图 LCD1602内带有80x8位（80字节）的RAM缓冲区，但只有每一列的前16个字符才会显示在屏幕上，如果写入了前16给以外的地址，则显示不出来，当屏幕整体移动一定位时，可以显示原本不显示的数据，两边地址的数据也会移动\n指令说明 初始化步骤一般为\n显示模式设置 显示开/关光标设置 数据控制 数据指针设置（即选择要存放数据的地址） 读或写数据 Proteus仿真原理图 程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 #include \u0026lt;reg52.h\u0026gt; sbit E\t= P2^6; sbit RS = P2^4; sbit RW = P2^5; sbit S1 = P3^0; sbit S2 = P3^1; sbit S3 = P3^2; sbit S4 = P3^3; #define LCD_Data P0 unsigned long second = 0; unsigned char Hour = 0; unsigned char Min = 0; unsigned char Sec = 0; unsigned char flag1 = 1; unsigned int time0 = 0; unsigned int time1 = 0; unsigned char S1_flag0 = 1; unsigned char S1_flag1 = 1; unsigned char S2_flag0 = 1; unsigned char S2_flag1 = 1; unsigned char S3_flag0 = 1; unsigned char S3_flag1 = 1; unsigned char S4_flag0 = 1; unsigned char S4_flag1 = 1; void LCD_Delay(unsigned char time) {\twhile(time--) { unsigned char i = 0; for(i = 0; i\u0026lt;123;i++); } } void LCD_WriteCom(unsigned char com) {\tRS = 0; RW = 0; LCD_Data = com; E = 1; LCD_Delay(1); E = 0; LCD_Delay(1); } void LCD_WriteData(unsigned char Data) {\tRS = 1; RW = 0; LCD_Data = Data; E = 1; LCD_Delay(1); E = 0; LCD_Delay(1); } void LCD_Init(void) { LCD_WriteCom(0x38);\t//设置16x2显示，5x7点阵，8位数据接口 LCD_WriteCom(0x0C);\t// 0000 1100 LCD_WriteCom(0x06);\t//0000 0110 LCD_WriteCom(0x01);\t//清除 复位 } void LCD_SetCursor(unsigned Line, unsigned char Column) { if(Line == 1) { LCD_WriteCom(0x80|(Column - 1)); } else { LCD_WriteCom(0x80|(Column) + 0x40); } } void LCD_ShowChar(unsigned char Line, unsigned char Column,unsigned char Char) { LCD_SetCursor(Line, Column); LCD_WriteData(Char); } void LCD_ShowNum(unsigned char Line, unsigned char Column, unsigned char Num) { LCD_SetCursor(Line, Column); LCD_WriteData(\u0026#39;0\u0026#39; + Num); } void Clock_Set(unsigned char hour,unsigned char min,unsigned char sec) { second =(hour*3600) + (min*60) +(sec); } void Clock_Config(void) { Hour =(second / 3600 / 10 * 10 + second / 3600 % 10); Min = (second % 3600 / 60 / 10 * 10 + second % 3600 / 60 % 10); Sec = (second % 3600 % 60 / 10 * 10 + second % 3600 % 60 % 10); } void Time_Clock(void) { LCD_ShowNum(1,1,Hour / 10); LCD_ShowNum(1,2,Hour % 10);\t//时 LCD_ShowNum(1,4,Min / 10); LCD_ShowNum(1,5,Min\t% 10);\t//分 LCD_ShowNum(1,7,Sec / 10); LCD_ShowNum(1,8,Sec % 10);\t//秒 if(flag1 == 1) { LCD_ShowChar(1,3,\u0026#39;:\u0026#39;); LCD_ShowChar(1,6,\u0026#39;:\u0026#39;);\t} else if(flag1 == 0) { LCD_ShowChar(1,3,\u0026#39; \u0026#39;); LCD_ShowChar(1,6,\u0026#39; \u0026#39;);\t} if(Hour \u0026gt; 23) { Hour = 0; } if(Min \u0026gt; 59) { Min = 0; } if(Sec \u0026gt; 59) { Sec = 0; } } void Time_Init(void) { EA = 1; TMOD = 0x01; ET0 = 1; TR0 = 1; TH0 = 64535 / 256; TL0 = 64535 % 256; } void main(void) { LCD_Init(); Time_Init(); Clock_Set(12,34,03); //设置时间 Clock_Config(); while(1) { Time_Clock(); } }\tvoid Time_IT(void) interrupt 1 { time0 ++; time1 ++; TH0 = 64535/256; TL0 = 64535%256; if(time0 == 500) {\tif(flag1 == 0) { flag1 = 1; } else if(flag1 == 1) { flag1 = 0; } time0 =0; } if(time1 == 20)\t//非阻塞按键扫描 { S1_flag1 = S1_flag0;\t//保存上一次的值 S1_flag0 = S1;\t//获取新的值 S2_flag1 = S2_flag0;\t//保存上一次的值 S2_flag0 = S2;\t//获取新的值 S3_flag1 = S3_flag0;\t//保存上一次的值 S3_flag0 = S3;\t//获取新的值 S4_flag1 = S4_flag0;\t//保存上一次的值 S4_flag0 = S4;\t//获取新的值 if(S1_flag1 == 1 \u0026amp;\u0026amp; S1_flag0 == 0) { Hour++; } if(S2_flag1 == 1 \u0026amp;\u0026amp; S2_flag0 == 0) { Hour--; } if(S3_flag1 == 1 \u0026amp;\u0026amp; S3_flag0 == 0) { Min++; } if(S4_flag1 == 1 \u0026amp;\u0026amp; S4_flag0 == 0) { Min--; } time1 = 0; } } ","date":"2024-11-13T22:13:15+08:00","permalink":"https://Hui404.github.io/p/c51%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8Elcd1602%E6%98%BE%E7%A4%BA%E4%BB%A3%E7%A0%81/","title":"C51单片机与LCD1602显示代码"},{"content":"创建新博客\n1 2 3 4 hugo new content post/new/index.md #post 为文件夹 #new 博客名 #index md文件的名字 本地部署\n1 hugo server -D 上传博客\n1 2 3 4 5 6 7 8 git add . #添加文件 git commit -m \u0026#34;updata\u0026#34; #上传信息 git push #推送到远端 ","date":"2024-11-13T22:03:21+08:00","permalink":"https://Hui404.github.io/p/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0/","title":"博客上传"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://Hui404.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://Hui404.github.io/p/test-chinese/","title":"Chinese Test"}]